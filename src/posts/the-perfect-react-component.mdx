---
title: The perfect React component
previewImage: https://source.unsplash.com/A-NVHPka9Rk/1920x1280
publishedDate: 2024-01-20T13:00:00.000Z
---

I love React. It just makes so much sense to me personally how it all works. I love the fact that
it's _just Javascript_. I love the freedom you have when figuring out how to design and arrange your
components. In some strange way, I even love all of the footguns you have to understand and avoid.

But if you've been writing React for any amount of time, you'll probably agree that it's not
entirely clear what would be the best way to write React or structure your code. The official React
docs definitely don't form any kind of concrete opinion on the topic - they just lay out some vague
conceptual best practices. Everyone just kind of comes up with their own way to do things.

This means that every time you open a new codebase you'll have to spend a bit of time getting used
to the patterns used there. And most often these patterns don't have much thought behind them: they
just happened to form in the way that they did. In the best case, the developers working on the
codebase at least formed some conventions around these patterns and tried to stay consistent with
them. In my experience though, React codebases are often a mixed bag of different patterns, each of
which were popular at a given point in time until a new preferred pattern emerged.

The idea of this article isn't to be a complete styleguide on how to write React. What I want to do
is present the anatomy of what I _personally_ think is the best way to structure just a single
isolated React component, and why. Let's begin!

# Imports

Let's start from the top of the file and work our way down from there. You might think that imports
aren't a thing that deserves a whole lot of attention, but I tend to disagree. Clean and organised
imports make a world of difference (and have some practical benefits too, more on that below)!

A well-organised imports section looks something like this:

```tsx
import React from 'react';

import { range } from 'lodash';

import { Typography } from '@components/Typography';

import { Layout } from '../../../Layout';
import { Avatar } from './Avatar';
import { getAvatarSrc, getFormattedName } from './utils';
```

### The key things to notice here:

**The imports are sorted, in order of how generic the import is.** React imports are always at the
top, 3rd party library code is next, application-wide shared code like component library components
are after that, and relative imports come last. This makes the imports very easy to quickly scan,
and if you're looking for something specific you can easily find the right place to look.

**The usage of named vs. default imports is consistent.** Personally I prefer always using named
imports over default imports, although this isn't always possible with 3rd party packages. There's a
few practical benefits to this appraoach:

- It's easier to add more imports from a file/package
- Intellisense autocomplete works more reliably
- You can't import things with the wrong name

To expand on the topic of wrongly named imports - let's say you have a component named `Title` which
you import like this:

```tsx
import Title from './Title';
```

If you decide to rename that component to let's say `Typography`, and your editor automatically
fixes the import path for you, that will turn into this:

```tsx
import Title from './Typography';
```

That's not great! This kind of wrongly named import easily leads to confusion. With named imports,
you avoid this problem entirely.

### How on earth do I enforce something like this??

It would be practically impossible to maintain this kind of strict order of imports manually. As
with many things, the answer is to automate the issue with tooling. For this case, I can recommend a
Prettier plugin called
[`prettier-plugin-sort-imports`](https://github.com/IanVS/prettier-plugin-sort-imports) - you can
define your preferred import ordering and every time you save a file the imports will be ordered
just like you want them.

And I'll mention one more added bonus of sorting imports - you'll have a LOT less merge conflicts
related to your imports, as they only change when something actually changes.

# Props

Ah, props. This is in my humble opinion the most important part of writing React. Well designed and
documented props interfaces are the key to React code that is enjoyable to use and easy to
understand. Poorly designed and messy props interfaces on the other hand: an absolute headache, and
the road to ruin.

Again, let's start with an example of what I would consider a quality props interface for an
imaginary date picker component:

```tsx
export type DatePickerProps = {
	/**
	 * The value of the date picker (ISO 8601 date string), or null if no value
	 */
	value: string | null;
	/**
	 * A callback fired when the user selects a new value
	 */
	onChange: (value: string) => void;
	/**
	 * The date format to display the date as
	 *
	 * @see Supported formats: https://date-fns.org/v3.6.0/docs/format
	 *
	 * @default "MM/dd/yyyy"
	 */
	format?: string;
	/**
	 * Whether to disable the date picker
	 *
	 * @default false
	 */
	disabled?: boolean;
};

export const DatePicker = (props: DatePickerProps) => {
	//...
};
```

Let's break it down:

**Naming your props interface.** I think the only correct way to name your component props is to use
the pattern `{ComponentName}Props`. This is an easy and intuitive convention to follow, and makes it
super easy to import these interfaces in other files, should you need them. Sidenote: you should
also always export your props interface by default.

**Naming your props.** Try to follow a shared convention with prop names. For controlled components
like inputs and pickers, I personally always use the `value / onChange` combination for controlling
the value (as opposed to something like `date / onDateChange`), because:

- You don't need to figure out the naming case by case, when building the component or when using it
- The TypeScript type definitions and JSDoc comments already document what the expected type of the
  prop is, so there's no need to duplicate that information in the prop name.

Regarding other props, try to be consistent with common prop names that appear a lot in your
codebase: don't mix different conventions like using `disabled` in one component, and `isDisabled`
in another.

**Ordering your props.** In general, I think the appropriate way to order your props (from top to
bottom) is in order of importance. There's no need to overthink it: a good enough rule of thumb is
to just have required props at the top, and optional ones at the bottom.

**Documenting your props.** Writing JSDoc comments for your props is a really nice habit to get
into. This makes a massive difference when someone else (or you yourself) later tries to work with
this component and quickly understand how it works. In general, you should aim for the user not
needing to look at the component implementation at all to understand how to use it. What's more,
tools like GitHub Copilot make this excercise in most cases a matter of creating an empty comment
and pressing tab.

**Nullable props.** Consider when to use optional props (can be omitted entirely) and when to use
nullable props. This is an important part of documenting the importance of a prop. In our example
case, the `value` prop is nullable because we want the user to be aware that this is an important
prop - and if you want to pass it in as nullish, then you need to do that explicitly. The goal here
is that the Typescript compiler warns the user whenever they've missed something important.

# The component body

Okay then, on to the component implementation itself. The good news is that if you've put a bit of
effort into nicely designing and documenting the external API of your component (the props
interface), this part is actually not that important! As said above, if the external API is good
enough and the component works as documented, the developer using your component shouldn't need to
look at or even care about the internal implementation.

That being said, when the time comes to refactor or adjust the behaviour of the component, it saves
a lot of time if it's been built in a clean and understandable way. You often hear about rules like
"components should never be more than 100 lines" or similar - but I think those are not very useful
rules because there are so many different kinds of components.

Bloated and hard to understand React components are not the result of some magical line count being
exceeded. Instead, it's usually caused by a combination of code smells that would make even a small
component hard to understand and modify. Below are in my opinion the four most important DO's and
DON'Ts.

### Grouping logic

I think clean React components have some kind of logical grouping of the different kinds of things
it includes. For me, the intuitive and practical way to order and group things is the following:

- 1. Setup
- 2. State
- 3. Functions
- 4. Side-effects
- 5. Rendering

For our `DatePicker` component, it could look like this for example (comments added here just for
clarity, but please don't add comments like this to your actual code :D):

```tsx
export const DatePicker = (props: DatePickerProps) => {
	// Setup (prop destructuring, global hook calls, and so on)
	const { value, onChange } = props;
	const theme = useTheme();
	const { t } = useTranslation();

	// State (the local state of the component)
	const [isOpen, setOpen] = useState<boolean>(false);

	// Functions (change handlers and other needed functions)
	const handleDateChange = useCallback(
		(date: string) => {
			onChange(date);
			setOpen(false);
		},
		[onChange],
	);

	const handleKeyPress = useCallback((key: string) => {
		if (key === 'Esc') {
			setOpen(false);
		}
	}, []);

	// Side-effects
	useEffect(() => {
		const now = new Date().toISOString();
		if (value > now) {
			onChange(now);
		}
	}, [value, onChange]);

	// Rendering (whatever the component renders to the UI)
	return (
		<div className="date-picker">
			<label>Choose date</label>
			<div>{/* ... */}</div>
		</div>
	);
};
```

### Using conditional returns sparingly

Conditional returns are sometimes certainly needed, but in my opinion they are also vastly over-used
and there's often a better solution available. In many cases a conditional return is a bit of a code
smell and a sign of a poorly designed props interface or issues elsewhere in the application.

One case where I see this being mis-used all of the time is when handling authentication state.
Imagine we have an app where the user can either be logged in, or not. Some functionalities of the
app only make sense in the case where we have a logged-in user, like for example the profile page.

The implementation sometimes looks something like this:

```tsx
export const ProfilePage = () => {
	const { user } = useAuth();

	if (!user) {
		return null;
	}

	return (
		<div>
			<h1>Hello, {user.name}!</h1>
		</div>
	);
};
```

This is problematic because the whole `ProfilePage` component doesn't make any sense without an
active user! We shouldn't ever be even rendering this component if there's not a user - and the
conditional null return is just an escape hatch to sweep the issue under the rug.

It would arguably be better design if we prevented developers from even using this component without
an active user - for example by requiring the user to be passed in as a prop.

### Don't embed utilities in components

Another thing that sometimes happens is that components get bloated with a lot of "utility logic".
Going back to our `DatePicker` example, an example of that could be something like this:

```tsx
export const DatePicker = (props: DatePickerProps) => {
	const { value, format } = props;

	const getFormattedValue = () => {
		if (!value) return 'Choose date';

		const date = new Date(value);
		switch (format) {
			case 'mm/dd/yy': {
				return `${date.getMonths()}/${date.getDays()}/${date.getYears()}`;
			}
			case 'mm/yy': {
				return `${date.getMonths()}/${date.getYears()}`;
			}
		}
	};

	return (
		<div>
			<label>Choose date</label>
			<p>{getFormattedValue()}</p>
		</div>
	);
};
```

This kind of utility logic embedded within a component is a code smell because:

- The function easily becomes unpure - instead of taking explicit arguments, it just kind of grabs
  what it needs from the component body as implicit arguments. And in the worst case, there's a mix
  between explicit and implicit arguments.
- The functionality can't be re-used elsewhere, even if it's quite generic in nature
- The function can't be unit tested

In my opinion, this is usually the kind of thing that happens when the developer got lazy or was in
a rush and felt like they could round a few corners to save a bit of time.

This kind of utility logic belongs in a separate utility module, which is generic in nature as
opposed to tied to this specific use-case - and ideally unit tested:

```tsx

import { getFormattedDate } from 'modules/dates';

export const DatePicker = (props: DatePickerProps) => {
  const { value, format } = props;


  return(
	<div>
      <label>Choose date</label>
	  <p>{getFormattedDate(value, format) ?? "Choose date"}
	</div>
  )
}
```

### Use sub-components when needed

Another thing that often contributes to overly bloated components is not using sub-components where
appropriate, but instead trying to include everything into a single component. A prime example of
this could be some kind of component that consists of many distinct pieces - like for example a
dialog - and in an effort to make the implementation more readable, the developer separated these
different pieces to their own "render functions":

```tsx
const AlertDialog = (props: AlertDialogProps) => {
	const { title, content, onClose, onCancel, onConfirm } = props;

	const renderHeader = () => {
		return (
			<div className="alert-dialog-header">
				<h4>{title}</h4>
				<CloseButton onClick={onClose} />
			</div>
		);
	};

	const renderBody = () => {
		return (
			<div className="alert-dialog-body">
				<p>{content}</p>
			</div>
		);
	};

	const renderActions = () => {
		return (
			<div className="alert-dialog-actions">
				<button onClick={onCancel}>Cancel</button>
				<button onClick={onConfirm}>Confirm</button>
			</div>
		);
	};

	return (
		<div className="alert-dialog-paper">
			{renderHeader()}
			{renderBody()}
			{renderActions()}
		</div>
	);
};
```

This to me is a big code smell because it seems to be forgetting that React kind of has a pretty
well-established solution for this need: components! :D While this example might still look pretty
readable, and it is, this is greatly simplified from what you can often run into in the real world.

Here we should definitely take advantage of sub-components - and the component could instead look
like this:

```tsx
export const AlertDialog = (props: AlertDialogProps) => {
	const { title, content, onClose, onCancel, onConfirm } = props;

	return (
		<AlertDialogWrapper>
			<AlertDialogHeader title={title} onClose={onClose} />
			<AlertDialogBody content={content} />
			<AlertDialogActions onCancel={onCancel} onConfirm={onConfirm} />
		</AlertDialogWrapper>
	);
};
```

A lot easier to read, no? In general, I would advise against ever using these kinds of "render
functions" - they are almost always nothing more than a lazy way to define a component (which you
should be doing instead).

# Thoughts

I think clean code is a hard to thing to maintain, especially when trying to balance it with tight
project deadlines and other pressure factors. It's easy to fall into the trap of thinking that it's
faster for you to do something in a quick and dirty way, even if you know that you _should_ spend a
bit more time to clean it up. Or maybe it's ok if we just release this as-is, and
[clean it up later](https://xkcd.com/1983/)?

But as said, it's a trap: quick and dirty solutions are only faster if you've never spent the effort
to build the muscle memory to do things in a better way. But if you have that muscle memory, and
you've spent time and effort thinking about these things, you'll notice that it's actually faster
for you to do things nicely simply because it's the first approach that comes to your mind.

Code quality is also very contagious. Much like when you visit a messy house, a messy codebase is
almost like an invitation to keep making the mess worse - it's clear that the owner doesn't really
care about it. If the sink is already full of dirty dishes, that's probably where your dishes are
going as well.

A clean and organised codebase compels you to at least try and follow the quality standards and
structures in place. If there's not a dirty dish in sight, surely it would feel weird to leave yours
on the table. Instead, you might think to ask: "hey, where's the dishwasher - or where should I put
these?"
